二进制是如何计数的？
规定：从最低位开始满二向高位进一
这一样规定和十进制相似，只不过十进制是满十进一
可以记录下每一个数字，做到不遗漏，不重复。
十进制我们以0这个数作为正整数和负整数的分界；
假定二进制也以000 000 00（给八位）作为正整数和负数的分界；


为什么二进制以补码的形式存储负数，以及二进制数的运算是怎么进行的？

任何一个数加上他的相反数都为0 
十进制下1+（-1）=0；
转换成二进制（给并八位存储一个数）：000 000 01 + * = 000 000 00；（*表示二进制下的-1)
按照前面的规定满二进一*=111 111 11，如果用这个数来表示（-1）；现在2+（-2）=0，
用二进制表示就是000 000 10+ * =000 000 00；（*表示二进制下的-2）*=111 111 10;
还记得不管是二进制还是十进制是如何做到不重复不遗漏的计数吗？
他每次只加1，就是这么简单的一条性质！那么自然地想到2=1+1，3=1+2=1+1+1，4=1+3=1+1+2=1+1+1+1等等
二进制下也可以这么表示任意的一个数 000 000 10=000 000 01 + 000 000 01，000 000 11=000 000 01+000 000 10，000 001 00=000 000 01+000 000 11；很自然的000 000 01 可以表示任意的正整数，
任何一个正整数数都可拆分成000 000 01+*形式，同理*可继续向下拆分，直到*=000 000 01；因此二进制数可以表示成多个000 000 01相加即可。由于相反数的和为0，正整数+负整数=000 000 00，根据前面的结论
正整数可以看成多个000 000 01相加，负整数表示成多个111 111 11相加，并且000 000 01和111 111 11的个数要一致，显然得出结论任何一个负二进制数可以表示成多个111 11111相加且个数与正二进制对应的个数一样。

回到之前的提问为什么计算机用补码存负数？
111 111 11取反为000 000 00 加一为000 000 01，反过来将000 000 01减一000 000 00 取反 111 111 11；
答案很明晰了：n*000 000 01 + n*111 111 11 =000 000 00;(n*表示n个二进制数相加）
而实际上正整数取反加一后结果正与n*111 111 11一致，原因很简单，无论是补码的方式还是n*111 111 11的形式与原码相加都为000 000 00。
至此介绍了补码的由来及存储的形式
计算机中二进制的运算就显得十分简单了。
